// Part of <https://miracle.systems/p/walkner-snf> licensed under <CC BY-NC-SA 4.0>

'use strict';

const http = require('http');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  expressId: 'express',
  userId: 'user',
  pubsubId: 'pubsub',
  sioId: 'sio',
  controllerClientId: 'messenger/client',
  remoteClientId: 'messenger/client',
  controllerId: 'controller',
  remoteApiId: 'remoteApi'
};

exports.models = [
  require('./models/snfTest')
];

exports.optionalModules = {
  'sio': require('./commands'),
  'mongoose user express controller remoteApi': require('./routes')
};

exports.start = (app, module) =>
{
  let programsChecked = false;

  module.currentTest = null;
  module.lastTest = null;

  app.broker.subscribe('messenger.client.connected', onClientConnected);
  app.broker.subscribe('controller.tagValuesChanged', onTagValuesChanged);
  app.broker.subscribe('snf.tests.started', (test) => onTestStarted(test));
  app.broker.subscribe('snf.tests.finished', (testId) => onTestFinished(testId, false));
  app.broker.subscribe('snf.tests.saved', (result) => onTestSaved(result));

  function onClientConnected(message)
  {
    if (message.socketType === 'req' && message.moduleName === module.config.controllerClientId)
    {
      onControllerClientConnected();
    }

    if (message.socketType === 'req' && message.moduleName === module.config.remoteClientId)
    {
      onRemoteClientConnected();
    }
  }

  function onControllerClientConnected()
  {
    app[module.config.controllerClientId].request('snf.tests.getData', null, (testData) =>
    {
      if (testData.currentTest)
      {
        onTestStarted(testData.currentTest);
      }
      else
      {
        onTestFinished(testData.lastTest, true);
      }
    });
  }

  function onRemoteClientConnected()
  {
    fetchCurrentOrderQty();
  }

  function onTagValuesChanged(message)
  {
    if (message.currentOrder)
    {
      fetchCurrentOrderQty();
    }

    checkPrograms();
  }

  function fetchCurrentOrderQty()
  {
    const controller = app[module.config.controllerId];
    const remoteApi = app[module.config.remoteApiId];

    if (!controller || !remoteApi)
    {
      return;
    }

    if (fetchCurrentOrderQty.timer)
    {
      clearTimeout(fetchCurrentOrderQty.timer);
      fetchCurrentOrderQty.timer = null;
    }

    const currentOrder = controller.values['currentOrder'];

    if (!currentOrder)
    {
      return;
    }

    const apiReq = {
      method: 'GET',
      url: '/snf/tests;getOrderQty',
      json: true,
      qs: {
        orderNo: currentOrder
      }
    };

    remoteApi.request(apiReq, (err, apiRes) =>
    {
      if (!err && (!apiRes.body || !apiRes.body.qtyTodo))
      {
        err = new Error('Invalid response.');
      }

      if (err)
      {
        module.error(err, 'Failed to get current quantity.');

        fetchCurrentOrderQty.timer = setTimeout(fetchCurrentOrderQty, 10000);

        return;
      }

      if (controller.values['currentOrder'] !== apiRes.body.orderNo)
      {
        return;
      }

      const currentQty = {
        qtyTodo: apiRes.body.qtyTodo,
        qtyDone: apiRes.body.qtyDone
      };

      controller.setTagValue('currentQty', currentQty, (err) =>
      {
        if (err)
        {
          module.error(err, 'Failed to set current quantity.');
        }
      });
    });
  }

  function checkPrograms()
  {
    if (programsChecked)
    {
      return;
    }

    programsChecked = true;

    const controller = app[module.config.controllerId];
    const remoteApi = app[module.config.remoteApiId];
    const programIds = new Set();

    ['30s', 'hrs', 'tester'].forEach(kind =>
    {
      const program = controller.values[`program.${kind}`];

      if (program && program._id)
      {
        programIds.add(program._id);
      }
    });

    if (!programIds.size)
    {
      return;
    }

    const req = {
      method: 'GET',
      url: `/snf/programs?_id=in=(${Array.from(programIds)})`,
      json: true
    };

    remoteApi.request(req, (err, res) =>
    {
      if (!err && (!res.body || res.body.totalCount == null))
      {
        err = new Error('Invalid response.');
      }

      if (err)
      {
        module.error(err, 'Failed to check programs.');

        programsChecked = false;

        return setTimeout(checkPrograms, 10000);
      }

      (res.body.collection || []).forEach(newProgram =>
      {
        const oldProgram = controller.values[`program.${newProgram.kind}`];

        if (!oldProgram
          || newProgram._id !== oldProgram._id
          || newProgram.updatedAt === oldProgram.updatedAt)
        {
          return;
        }

        controller.setTagValue(`program.${newProgram.kind}`, newProgram, (err) =>
        {
          if (err)
          {
            module.error(err, 'Failed to update program.', {newProgram});
          }
        });
      });
    });
  }

  function onTestSaved(result)
  {
    const controller = app[module.config.controllerId];

    if (!controller)
    {
      return;
    }

    if (controller.values['currentOrder'] !== result.orderNo)
    {
      return;
    }

    const currentQty = {
      qtyTodo: 0,
      ...controller.values['currentQty'],
      qtyDone: result.serialNo
    };

    controller.setTagValue('currentQty', currentQty, (err) =>
    {
      if (err)
      {
        module.error(err, 'Failed to set current quantity.');
      }
    });
  }

  function onTestStarted(test)
  {
    module.currentTest = test;

    app[module.config.pubsubId].publish('snf.tests.started', test);
  }

  function onTestFinished(testId, resync)
  {
    if (!testId)
    {
      return;
    }

    module.currentTest = null;

    module.SnfTest.findById(testId, (err, test) =>
    {
      if (err)
      {
        return module.error(err, "Failed to find a finished test.");
      }

      if (test)
      {
        module.lastTest = test.toJSON();

        if (!resync)
        {
          saveTestRemotely(module.lastTest, 1);
        }
      }
      else
      {
        module.warn("Couldn't find a finished test.", {testId});
      }

      app[module.config.pubsubId].publish('snf.tests.finished', test ? module.lastTest : null);
    });
  }

  function saveTestRemotely(test, tryNo)
  {
    const remoteApi = app[module.config.remoteApiId];

    if (!remoteApi)
    {
      return;
    }

    const req = {
      method: 'POST',
      url: '/snf/tests',
      json: true,
      body: test
    };

    remoteApi.request(req, (err, res) =>
    {
      if (!err && res.statusCode !== 200)
      {
        err = new Error(`Unexpected response status: ${res.statusCode}`);
      }

      if (err)
      {
        if (tryNo !== 3)
        {
          return setTimeout(saveTestRemotely, 1000, test, tryNo + 1);
        }

        return module.warn(err, 'Failed to save remote test result.', {testId: test._id});
      }

      const update = {
        $set: {
          orderNo: res.body.orderNo || '',
          serialNo: res.body.serialNo || 0
        }
      };

      module.SnfTest.updateOne({_id: test._id}, update, (err) =>
      {
        if (err)
        {
          return module.error(err, 'Failed to update test SN.', {test: res.body});
        }

        app[module.config.pubsubId].publish('snf.tests.saved', {
          _id: test._id,
          prodLine: test.prodLine,
          orderNo: res.body.orderNo || '',
          serialNo: res.body.serialNo || 0
        });
      });
    });
  }
};
